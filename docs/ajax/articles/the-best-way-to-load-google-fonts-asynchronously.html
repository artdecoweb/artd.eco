{
  "title": "The Best Way To Load Google Fonts Asynchronously.",
  "content": "<div class=\"container\">\n  <div class=\"row\">\n    <div class=\"col\">\n\n<h1 id=\"the-best-way-to-load-google-fonts-asynchronously\">The Best Way To Load Google Fonts Asynchronously</h1>\n\n<p class=\"H1Lead lead\">\n  &gt; Part II of <em>Advanced Google Font</em>. Go to Part I: <a href=\"/articles/how-to-load-google-fonts-asynchronously.html\">\n   How To Load Google Font Asynchronously</a>.\n</p>\n\n<div class=\"row mb-3\">\n  <div class=\"col-2 col-sm-2 col-lg-1\">\n    <img alt=\"anton photo\"\n      src=\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='100' height='100'/%3E\" data-io class=\"rounded img-fluid\" data-src=\"avatar/anton.JPG\">\n    <noscript><img alt=\"anton photo\" class=\"rounded img-fluid\" src=\"avatar/anton.JPG\"></noscript>\n  </div>\n  <div style=\"border-bottom: 1px solid grey;\" class=\"col-10 col-sm-7\">\n    <p class=\"text-right\" style=\"color: grey;\">\n      <span>Anton Dmukhovskiy, Senior Software Developer</span><br><span>8 November 2019</span> <span id=\"c6d6c\"><span data-loading>Loading sharing buttons...</span><noscript>Please enable JavaScript to Share</noscript></span>\n    </p>\n  </div>\n  <div class=\"col-sm-3 col-lg-4\">\n    Topics:\n    <a class=\"d-block\" href=\"/topics/page speed optimisation\">page speed optimisation</a>\n    <a class=\"d-block\" href=\"/topics/web fonts\">web fonts</a>\n  </div>\n</div>\n\n<p>\n  In the previous part, I've show the theory behind asynchronous web font stylesheet loading and illustrated the process of page loading with experiments around performance measurements. Based on this data, I'll show my technique loading fonts in the most efficient manner. At the end, I'll show how to make embed a font on a web page so that it's immediately used when rendering the page, without a FOUT.\n</p>\n\n<h2 id=\"advanced-loading-lemuriafont\">Advanced Loading: @lemuria/font</h2>\n\n<p>\n  As can be seen from the performance graphs above, there is one drawback to preloading web fonts stylesheets dynamically even with the preload link: fonts won't begin to download immediately after the stylesheet is downloaded, and will generally wait for after the initial render is finished. I've repeated the previous experiment multiple times, and I always see the same result. Plus, we're still to conglomerate all reflows. The proposed solution is JavaScript-based:\n</p>\n\n<ul>\n  <li>Preload the stylesheet as <span class=\"tm\">fetch</span> resource.</li>\n  <li>Instead of adding the link with the stylesheet to DOM, download it using XHR.</li>\n  <li>Parse the stylesheet to extract <span class=\"tm\">url()</span> links to fonts, add them do DOM as <span class=\"tm\">link</span> with <em>rel</em>=<strong>preload</strong> <em>as</em>=<strong>font</strong>. This will kick in downloading the fonts.</li>\n  <li>Wait for all fonts to load, then embed the stylesheet as inline style. This solves the problem.</li>\n  <li>If the browser doesn't support preload, just fallback to standard font loading.</li>\n</ul>\n\n<p>\n  Here's a simple to fetch stylesheet, while measuring performance:\n</p>\n\n<pre id=\"ccdbf6\"><code class=\"javascript hljs\">/**\n* @param {string} address The address to load.\n* @param {function(string)} cb The callback to call on complete.\n* @param {string} [marker] Performance annotation.\n*/\nconst fetchStylesheet = (address, cb, marker = '') =&gt; {\n performance.mark('xhr-start'+marker)\n const xhr = new XMLHttpRequest()\n xhr.onreadystatechange = () =&gt; {\n   if(xhr.readyState == 4) {\n     if (xhr.status == 200) {\n       cb(xhr.responseText)\n       performance.mark('xhr-end'+marker)\n       performance.measure('xhr'+marker, 'xhr-start'+marker, 'xhr-end'+marker)\n     } else {\n       console.error('Error loading webfont: server responded with code %s at %s',\n        xhr.status, address)\n     }\n   }\n }\n xhr.open('GET', address)\n try {\n   xhr.send(null)\n } catch (err) {\n   console.error(err)\n }\n}</code></pre>\n\n<p>\n  Our stylesheet parsing function uses a regex to extract URLs with unicode ranges of fonts, and creates an array like <span class=\"tm\">[{ font: 'url', range: /[regex]/ }]</span> for each font it found in the stylesheet.\n</p>\n\n<pre id=\"ccdbf\"><code class=\"javascript hljs\">function parseBody(result) {\n  const re = /url\\((.+?)\\).*?;\\s+unicode-range: (.+?);/g\n  let ranges = {}\n  const fonts = []\n  let a\n  while((a = re.exec(result))) {\n    const u = a[1]\n    const range = a[2]\n    fonts.push({ url: u, range })\n    ranges[range] = 1\n  }\n  ranges = Object.keys(ranges).reduce((acc, range) =&gt; {\n    const reg = range\n      .split(/,\\s/)\n      .map((r) =&gt; r.replace('U+', '\\\\u').replace('-', '-\\\\u'))\n      .join('').toLowerCase()\n    acc[range] = new RegExp(`[${reg}]`)\n    return acc\n  }, {})\n  // ...</code></pre>\n\n<p id=\"2-scenarios\">\n  There are 2 scenarios when we'll get the stylesheet ready: A) prior to HTML parsing, which can be because there's another stylesheet blocking the render, and because the connection is very fast; and B) after HTML parsing, when <span class=\"tm\">body</span> is available. In the first instance, we wouldn't know the unicode ranges that are present on the page, therefore they have to be supplied as additional information. If we know that we don't use <strong>latin-ext</strong> on the page, we'll just pass the unicode range for <strong>latin</strong> characters. This way, we don't have to download each single font in the stylesheet, wasting data.\n</p>\n\n<pre id=\"ccdbf1\"><code class=\"javascript hljs\">  // ..\n  const body = document.body ? document.body.textContent : ''\n  const validRanges = body ? Object.keys(ranges).reduce((acc, range) =&gt; {\n\n    // case B) body is loaded, text it against the regex.\n    const reg = ranges[range]\n    const valid = reg.test(body)\n    if (valid) acc[range] = true\n    return acc\n  }, {}) : Object.keys(ranges).reduce((acc, range) =&gt; {\n\n    // case A) body is not available, fallback to supplied ranges.\n    const valid = range in defaultRanges\n    if (valid) acc[range] = true\n    return acc\n  }, {})\n\n  // filter only fonts we need\n  urls = fonts.filter(({ range }) =&gt; {\n    return range in validRanges\n  }).map(({ url: u }) =&gt; u)\n\n  // if ranges are not supplied, and we're in case A, just add the stylesheet.\n  // we loose the advantage of eliminating continuous reflows due to fonts\n  // arriving independently at different times.\n  if (!urls.length) return loadedCb()\n\n  // preload fonts via link elements\n  // each appendChild has a cost, so bundle them into a fragment.\n  const fragment = document.createDocumentFragment()\n  urls.forEach((address, i) =&gt; {\n    const link = document.createElement('link')\n    link.href = address\n    link.rel = 'preload'\n    link.as = 'font'\n    const j = i + 1\n    performance.mark('link-preload-start'+j)\n    link.onload = () =&gt; loadedCb(j)\n    link.setAttribute('crossorigin', true)\n    fragment.appendChild(link)\n  })\n  document.head.appendChild(fragment)\n}</code></pre>\n\n<p>\n  Add some logic to keep track of parallel preloads, and embed the stylesheet when they all arrive.\n</p>\n\n<pre id=\"ccdbf2\"><code class=\"javascript hljs\">let FONT_CSS\nlet urls = []\nlet loaded = 0\n\n// the entry main: fetch CSS and call parseBody,\n// which will call loadedCb for each font.\nfunction startPreload(linkEl, marker = 'link') {\n  const href = linkEl.href\n  fetchStylesheet(href, (res) =&gt; {\n    FONT_CSS = res\n    parseBody(FONT_CSS)\n  }, '-' + marker)\n}\n\n/**\n * @param {number} [i] The index of the link\n */\nconst loadedCb = (i) =&gt; {\n  if (i) {\n    performance.mark('link-preload-end'+i)\n    performance.measure('link-preload', 'link-preload-start'+i, 'link-preload-end'+i)\n  }\n  loaded++\n  if (loaded &gt;= urls.length) {\n    const style = document.createElement('style')\n    style.innerHTML = FONT_CSS\n    document.head.appendChild(style)\n\n    performance.mark('agf-end')\n    performance.measure('@lemuria/font', 'agf-start', 'agf-end')\n  }\n}\n\n// kick in advanced google font preloading!\nstartPreload({ href: FONT }, 'js')</code></pre>\n\n<p>\n  I could have used the <span class=\"tm\">fetch</span> instead of XHR since its 2019, however I would need to add a polyfill and transpile async code. There's no performance difference between <span class=\"tm\">fetch</span> and <span class=\"tm\">XMLHttpRequest</span> APIs. One observation, is that with <span class=\"tm\">fetch</span>, data could be streamed, so if the response arrived in chunks, I could extract fonts as they come, but because the stylesheet is so small (&lt; 1kb), streaming is unnecessary. I've made a package called <span class=\"tm\">@lemuria/font</span> with this code which I run through <em>Google Closure Compiler</em>, so let's update our page:\n</p>\n\n<pre id=\"c6ce5\"><code class=\"xml hljs\">&lt;head&gt;\n  &lt;link rel=\"dns-prefetch\" href=\"//fonts.googleapis.com\"&gt;\n  &lt;link rel=\"preconnect\" href=\"https://fonts.gstatic.com\" crossorigin&gt;\n  &lt;link rel=\"preload\" href=\"https://fonts.googleapis.com/css?display=swap&amp;family=Gentium+Basic:400,400i,700|Limelight\" as=\"fetch\"&gt;\n  &lt;script&gt;\n    (function(){window[\"@lemuria/font\"]=function(q,k){function x(a){for(var f=/url\\((.+?)\\).*?;\\s+unicode-range: (.+?);/g,b={},d=[],h;h=f.exec(a);){var r=h[2];d.push({url:h[1],a:r});b[r]=1}b=Object.keys(b).reduce(function(c,e){var g=e.split(/,\\s/).map(function(l){return l.replace(\"U+\",\"\\\\u\").replace(\"-\",\"-\\\\u\")}).join(\"\").toLowerCase();c[e]=new RegExp(\"[\"+g+\"]\");return c},{});var t=document.body?document.body.textContent:\"\",y=t?Object.keys(b).reduce(function(c,e){b[e].test(t)&amp;&amp;(c[e]=!0);return c},{}):Object.keys(b).reduce(function(c,\n    e){e in k&amp;&amp;(c[e]=!0);return c},{});m=d.filter(function(c){return c.a in y}).map(function(c){return c.url});if(!m.length)return u();var v=document.createDocumentFragment();m.forEach(function(c,e){var g=document.createElement(\"link\");g.href=c;g.rel=\"preload\";g.as=\"font\";var l=e+1;performance.mark(\"link-preload-start\"+l);g.onload=function(){return u(l)};g.setAttribute(\"crossorigin\",!0);v.appendChild(g)});document.head.appendChild(v)}k=void 0===k?{}:k;var n=document.createElement(\"link\");if(function(a,\n    f){if(!a||!a.supports)return!1;try{return a.supports(f)}catch(b){return!1}}(n.relList,\"preload\")){var z=function(a,f,b){b=void 0===b?\"\":b;performance.mark(\"xhr-start\"+b);var d=new XMLHttpRequest;d.onreadystatechange=function(){4==d.readyState&amp;&amp;(200==d.status?(f(d.responseText),performance.mark(\"xhr-end\"+b),performance.measure(\"xhr\"+b,\"xhr-start\"+b,\"xhr-end\"+b)):console.error(\"Error loading webfont: server responded with code %s at %s\",d.status,a))};d.open(\"GET\",a);try{d.send(null)}catch(h){console.error(h)}};\n    performance.mark(\"agf-start\");var p;(function(a,f){z(a.href,function(b){p=b;x(p)},\"-\"+(void 0===f?\"link\":f))})({href:q},\"js\");var m=[],w=0,u=function(a){a&amp;&amp;(performance.mark(\"link-preload-end\"+a),performance.measure(\"link-preload\",\"link-preload-start\"+a,\"link-preload-end\"+a));w++;w&gt;=m.length&amp;&amp;(a=document.createElement(\"style\"),a.innerHTML=p,document.head.appendChild(a),performance.mark(\"agf-end\"),performance.measure(\"@lemuria/font\",\"agf-start\",\"agf-end\"))}}else n.rel=\"stylesheet\",n.href=q,document.head.appendChild(n)};}).call(this);\n\n    window['@lemuria/font']\n      ('https://fonts.googleapis.com/css?display=swap&amp;family=Gentium+Basic:400,400i,700|Limelight')\n  &lt;/script&gt;\n&lt;/head&gt;</code></pre>\n\n<p>\n  I've left plenty of performance markers, but there's a version that doesn't have them. What does the resulting timeline look like? Have we solved the problem of throttling fonts' reflows?\n  <p>\n  </div></div></div>\n  <div class=\"container-fluid position-relative mb-3 p-3 rounded\" style=\"overflow: hidden;\"\n    id=\"fig-advanced-loading\">\n    <div class=\" Parallax\" data-loading style=\"z-index: -1;\" id=\"c709f7\"></div>\n    <div style=\"z-index: -1;\" class=\"Parallax\"></div>\n    <noscript>\n      <div class=\" Parallax\" style=\"background-image: url(/img/letters/background.png); z-index: -1;\"></div>\n    </noscript>\n    <p class=\"text-center\">\n      <img alt=\"Advanced asynchronous Google Font performance: achieving single reflow.\"\n        src=\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='761' height='659'/%3E\" data-io class=\"border rounded img-fluid\"\n        data-src=\"best-google-font-2/graphics/dev8.png\">\n      <noscript>\n        <img alt=\"Advanced asynchronous Google Font performance: achieving single reflow.\"\n          class=\"border rounded img-fluid\" src=\"best-google-font-2/graphics/dev8.png\">\n      </noscript>\n    </p>\n    <h5 id=\"figure-9-advanced-asynchronous-google-font-performance-achieving-single-reflow\"\n      class=\"m-0 d-inline-block\" style=\"background: white;\">\n      Figure 9: Advanced asynchronous Google Font performance: achieving single reflow.\n    </h5>\n  </div>\n  <div class=\"container\"><div class=\"row\"><div class=\"col\">\n  <ol>\n    <li>As soon as the page starts parsing, we begin the XHR request, but the XHR resource has already started downloading. The script evaluation takes <em>10ms</em>.</li>\n    <li>The download completes, but the thread is blocked. The XHR waits until it's freed to call the callback. Fonts don't begin to download but we can't do anything about it. Once the thread is available, we inject 4 links and assign an <span class=\"tm\">onload</span> listener to each them.</li>\n    <li>When all <span class=\"tm\">onload</span> events have fired, we add the stylesheet to DOM as a style. Despite the fact that fonts arrived at different times, we only see one reflow which takes 100ms. The page's <span class=\"tm\">onload</span> event is thus delivered quicker and the users and Google are happy.</li>\n  </ol>\n  <p>\n  Bingo bongo, we've achieved the maximum optimisation of a Google Font. Let's just see what if there's a render blocking resource, such as an external CSS that would give us some additional time to fetch the web font stylesheet:\n</p>\n\n</div></div></div>\n<div class=\"container-fluid position-relative mb-3 p-3 rounded\" style=\"overflow: hidden;\">\n  <div class=\" Parallax\" data-loading style=\"z-index: -1;\" id=\"c709f8\"></div>\n  <div style=\"z-index: -1;\" class=\"Parallax\"></div>\n  <noscript>\n    <div class=\" Parallax\" style=\"background-image: url(/img/letters/background.png); z-index: -1;\"></div>\n  </noscript>\n  <p class=\"text-center\">\n    <img alt=\"@Lemuria/font parsing starting before body is available without default unicode-ranges.\"\n      src=\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='761' height='659'/%3E\" data-io class=\"border rounded img-fluid\"\n      data-src=\"best-google-font-2/graphics/dev9.png\">\n    <noscript>\n      <img alt=\"@Lemuria/font parsing starting before body is available without default unicode-ranges.\"\n        class=\"border rounded img-fluid\" src=\"best-google-font-2/graphics/dev9.png\">\n    </noscript>\n  </p>\n  <h5\n    id=\"figure-1-lemuriafont-parsing-starting-before-body-is-available-without-default-unicode-ranges\" class=\"m-0 d-inline-block\" style=\"background: white;\">\n    Figure 1: @Lemuria/font parsing starting before body is available without default unicode-ranges.\n  </h5>\n</div>\n<div class=\"container\"><div class=\"row\"><div class=\"col\">\n\n<ol>\n  <li>The advanced font loading script is executed, and taps into the preload download, but by the time the XHR is finished, the script cannot find <span class=\"tm\">body</span> and there are no default unicode ranges. It falls back to essentially just appending a link tag with the style to the head.</li>\n  <li>The external stylesheet is begins to parse only now.</li>\n  <li>Fonts arrive one by one.</li>\n</ol>\n\n<p>\n  In this experiment, instead of inlining the page style, I added a link to it, so that the browser has to download it. Although such download happens really quickly, the page nevertheless is slowed down by much more than just the download time. Unlike in the previous case, now when the <span class=\"tm\">@lemuria/font</span> function is executed, the body is still not available because the parsing has not started. This just shows that it's not just the download speed that increases the start up time for external stylesheets, but their loading time also <em>total: 84.12 ms (15.12 ms network transfer + 69.01 ms resource loading)</em>.\n</p>\n\n  <p>\n    For a scary moment though, I thought that I might be giving wrong advice when saying to append a <span class=\"tm\">link</span> tag dynamically into the head, and it will actually block the page from rendering. For example, on the graph above, there are some gaps in the timeline after the web font stylesheet is inserted, but before the external CSS is parsed, that could indicate that the page was render-blocked. However, it's not the case as shown below, and the reason for these gaps is that the browser has to pause to parse the external style, allowing some async JS to report to the main thread via callbacks (e.g., here, XHR is completed quicker compared to the <a href=\"#fig-advanced-loading\">previous case</a>, where it had to wait for the main thread to unlock since there were no gaps). Below is the proof.\n  </p>\n\n</div></div></div>\n<div class=\"container-fluid position-relative mb-3 p-3 rounded\" style=\"overflow: hidden;\">\n  <div class=\" Parallax\" data-loading style=\"z-index: -1;\" id=\"c709f\"></div>\n  <div style=\"z-index: -1;\" class=\"Parallax\"></div>\n  <noscript>\n    <div class=\" Parallax\" style=\"background-image: url(/img/letters/background.png); z-index: -1;\"></div>\n  </noscript>\n  <p class=\"text-center\">\n    <img alt=\"Dynamic insertion of a link with JS does not block page render.\"\n      src=\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='639' height='486'/%3E\" data-io class=\"border rounded img-fluid\"\n      data-src=\"best-google-font-2/graphics/dev-check.gif\">\n    <noscript>\n      <img alt=\"Dynamic insertion of a link with JS does not block page render.\"\n        class=\"border rounded img-fluid\" src=\"best-google-font-2/graphics/dev-check.gif\">\n    </noscript>\n  </p>\n  <h5 id=\"figure-2-dynamic-insertion-of-a-link-with-js-does-not-block-page-render\"\n    class=\"m-0 d-inline-block\" style=\"background: white;\">\n    Figure 2: Dynamic insertion of a link with JS does not block page render.\n  </h5>\n</div>\n<div class=\"container\"><div class=\"row\"><div class=\"col\">\n\n<p>\n  Essentially all I've done is added an external stylesheet dynamically, but throttled it server-side with a middleware function. Because the page continued to render, it's safe to say that adding a link with JS in the head will not block the main thread.\n</p>\n\n<pre id=\"c6ce51\"><code class=\"xml hljs\">&lt;head&gt;\n&lt;link rel=\"preload\" href=\"/throttle.css\" as=\"style\"&gt;\n  &lt;script&gt;\n    const link = document.createElement('link')\n    link.href = '/throttle.css'\n    link.rel = 'stylesheet'\n    performance.mark('add-stylesheet')\n    document.head.appendChild(link)\n    link.onload = () =&gt; {\n      performance.measure('stylesheet-onload', 'add-stylesheet');\n    }\n  &lt;/script&gt;\n&lt;/head&gt;</code></pre>\n\n<pre id=\"ccdbf3\"><code class=\"javascript hljs\">// Koa middleware\nasync throttle(ctx, next) {\n  if (ctx.path == '/throttle.css') {\n    await new Promise(r =&gt; setTimeout(r, 500))\n    ctx.type = 'text/css'\n    ctx.body = ''\n  }\n  await next()\n}</code></pre>\n\n<p>\n  So finally, let me show a case with an external stylesheet, and with unicode-range. The unicode-range can be looked up in the Google's servers response, but I'm quite sure they are pretty static so you wouldn't have to do it often (but keep an eye out for them).\n</p>\n\n<pre id=\"c6ce52\"><code class=\"xml hljs\">&lt;head&gt;\n  &lt;link rel=\"preload\" crossorigin href=\"https://fonts.googleapis.com/css?display=swap&amp;family=Gentium+Basic:400,400i,700|Limelight\" as=\"fetch\"&gt;\n  &lt;script&gt;\n    // @lemuria/font source\n    var range = 'U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, ' +\n                'U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD'\n    window['@lemuria/font']\n      ('https://fonts.googleapis.com/css?display=swap&amp;family=Gentium+Basic:400,400i,700|Limelight', {\n        [range]: true, // latin range\n      })\n  &lt;/script&gt;\n&lt;/head&gt;</code></pre>\n\n</div></div></div>\n<div class=\"container-fluid position-relative mb-3 p-3 rounded\" style=\"overflow: hidden;\">\n  <div class=\" Parallax\" data-loading style=\"z-index: -1;\" id=\"c709f1\"></div>\n  <div style=\"z-index: -1;\" class=\"Parallax\"></div>\n  <noscript>\n    <div class=\" Parallax\" style=\"background-image: url(/img/letters/background.png); z-index: -1;\"></div>\n  </noscript>\n  <p class=\"text-center\">\n    <img\n      alt=\"@Lemuria/font with unicode-range info allows to download fonts in parallel to the main thread.\" src=\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='817' height='597'/%3E\"\n      data-io class=\"border rounded img-fluid\" data-src=\"best-google-font-2/graphics/dev10.png\">\n    <noscript>\n      <img\n        alt=\"@Lemuria/font with unicode-range info allows to download fonts in parallel to the main thread.\" class=\"border rounded img-fluid\" src=\"best-google-font-2/graphics/dev10.png\">\n    </noscript>\n  </p>\n  <h5\n    id=\"figure-3-lemuriafont-with-unicode-range-info-allows-to-download-fonts-in-parallel-to-the-main-thread\" class=\"m-0 d-inline-block\" style=\"background: white;\">\n    Figure 3: @Lemuria/font with unicode-range info allows to download fonts in parallel to the main thread.\n  </h5>\n</div>\n<div class=\"container\"><div class=\"row\"><div class=\"col\">\n\n<ol>\n  <li>The font script begins the XHR request as soon as HTML starts to parse. It might look like the thread is blocked because the browser is not doing anything during the XHR, however it's not so otherwise there would be a long solid orange line saying \"Evaluating JS\", but there's just a gap. The browser is doing something, but there's no info to it. The XHR is async so it's not blocking the thread.</li>\n  <li>The XHR is finished but the body is not present. Because we've passed the desired <span class=\"tm\">unicode-range</span>, the script inserts the font preload links, and they begin to download. This allows to parallelise their download with the initial render.</li>\n  <li>Once the thread is freed (the <span style=\"background:blue; color:white\" class=\"px-2\"><abbr title=\"Dom Content Loaded\">DCL</abbr></span> event), there's a bit of work to do for other JS scripts on the page, after which the web font stylesheet is applied. Notice there's only <em>150ms</em> delay between the <span style=\"background:green; color:white\" class=\"px-2\"><abbr title=\"First Paint\">FP</abbr></span> and fonts being added which gives us the fastest FOUT so far.</li>\n</ol>\n\n<p>\n  Cool, I think we've optimised as much as possible out of <em>Google Fonts</em>. The final version enables to insert the stylesheet before the initial layout, and also downloads fonts in parallel to the main thread which is busy rendering. This is only possible if there are render blocking resources which will postpone the parsing for some time long enough for the web font stylesheet preload to complete. In case there are none, I've tried the following trick:\n</p>\n\n<pre id=\"c16f7\"><code class=\"xml hljs\">&lt;head&gt;\n  &lt;!-- ... --&gt;\n  &lt;link href=\"data:text/css;charset=utf-8,\" rel=\"stylesheet\"&gt;\n&lt;/head&gt;</code></pre>\n\n<p>\n  In words, I added a data-url link in hope that the browser will pause to download it which will give the XHR callback a chance to fire (it <a\n   onclick=\"document.querySelector(this.getAttribute('href')).scrollIntoView({behavior: 'smooth'}); return false\" href=\"#fig-advanced-loading\">\n   does not fire</a> if there are no external resources), however that didn't work 🤷‍♀️. Let me wrap up to conclusions.\n</p>\n\n<p class=\"SectionBreak\">\n  <a title=\"Back To Top\" href=\"#top\">\n    <img alt=\"section break\"\n      src=\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='40' height='15'/%3E\" data-io data-src=\"/section-breaks/0.svg\">\n    <noscript><img alt=\"section break\" src=\"/section-breaks/0.svg\"></noscript></a>\n</p>\n\n<h2 id=\"conclusions\">Conclusions</h2>\n\n<p>\n  Google Fonts are great because it's really easy to embed them and the service provides a variety of good-looking web fonts. The standard sync loading with a simple link tag, however, will lock the main thread and not prevent the page (even HTML won't start parsing) which we would like to avoid. Moreover, fonts will load independently, and each time they will cause a reflow of the page, which slows down the <span class=\"px-2\" style=\"background:red; color:white\"><abbr title=\"Load\">L</abbr></span> event delivery and frustrates the user. In summary, we've gone through the following stages for optimisation from the sync loading:\n</p>\n\n<h4 id=\"1-async-loading\" class=\"text-center\">1) Async Loading</h4>\n<hr>\n\n<div class=\"position-relative float-md-right pl-3 pb-3\" id=\"c5f46\">\n  <img alt=\"async google font animation\"\n    src=\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='505' height='299'/%3E\" data-io class=\"img-fluid\"\n    data-src=\"best-google-font-2/graphics/async-google-font.png\">\n  <noscript>\n    <img alt=\"async google font animation\" class=\"img-fluid\"\n      src=\"best-google-font-2/graphics/async-google-font.png\">\n  </noscript>\n</div>\n\n<p>\n  Instead of adding a link tag in the markup, we add a simple script to create the link dynamically. This technique allows to transform sync render-blocking loading of resources into async non-blocking loading, and eliminates the Lighthouse warning. We also add a preload link so that the resource begins to download immediately rather than waiting for the script to execute.\n</p>\n<p>\n  We've also looked at another method when instead of a script tag, the <span class=\"tm\">onload</span> attribute on the preload link is used to upgrade the <em>rel</em> from <strong>preload</strong> to <strong>stylesheet</strong>, however as I've shown, this has a disadvantage that if the stylesheet arrives after the initial render, it will cause an expensive reflow, despite the fact that fonts are not even loaded. Therefore I suggest it's better to use the traditional script element right under the preload link.\n</p>\n\n<h4 id=\"2-advanced-loading\" class=\"text-center\">2) Advanced Loading</h4>\n\n<hr>\n\n<p>\n  Although async loading better than sync one, it's still not perfect, because we still have multiple reflows due to independent font loading. I propose a solution where an Ajax request is made to fetch the stylesheet, extract urls to fonts, preload them, and once they are all ready, embed the stylesheet into DOM.\n</p>\n\n<div class=\"position-relative float-md-left pr-3 pb-3\" id=\"c228f\">\n  <img alt=\"advanced google font animation\"\n    src=\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='505' height='299'/%3E\" data-io class=\"img-fluid\"\n    data-src=\"best-google-font-2/graphics/advanced-google-font.png\">\n  <noscript>\n    <img alt=\"advanced google font animation\" class=\"img-fluid\"\n      src=\"best-google-font-2/graphics/advanced-google-font.png\">\n  </noscript>\n</div>\n\n<p>\n  Any external CSS will postpone the parsing of HTML until it's received, but not only for the length of its download time, but for the duration of its loading time, which might be much longer than the download one. <span style=\"background:green; color: white\">Therefore when we're talking about maximum optimisation, such as for a landing page of a product, we might want to embed the full stylesheet onto the page so that we don't have to wait for it.</span> The browser treats this case differently and the loading pattern is continuous, i.e., start of parsing leads to layout without any gaps. However, if we have a web portal with multiple pages that share same styles, like a forum, it might not be feasible to embed CSS onto each page. Here, we're not that concerned with making an impression on the user with lightning-fast pages, but just want to deliver content. These are 2 broad cases that each deserving its own treatment.\n</p>\n<p>\n  When there are no external CSS, our script will begin to download XHR, but will probably have to wait until the initial rendering is done to parse it and begin to download fonts. When there are external CSS that blocked the page, the script might get a chance to parse the stylesheet, but it won't have information about the <span class=\"tm\">body</span>'s content to correctly apply <span class=\"tm\">unicode-range</span>, therefore we can supply that info manually to prevent unused fonts from extended ranges from downloading. In the latter case, we will be able to download fonts in parallel to the main thread doing the layout job, and apply the style right after the thread is freed, that is after the <span style=\"background:blue; color:white\" class=\"px-2\"><abbr title=\"Dom Content Loaded\">DCL</abbr></span> event. This scenario is when the loading is the fastest.\n</p>\n\n<p>\n  There might be some disadvantages to the method:\n</p>\n\n<ol>\n  <li>The script might take up some time to evaluate and if it can create preload links before parsing of HTML, it will also take additional time to insert them into DOM (takes 5-20ms) on my computer. We might have saved some time because all fonts were injected at once, but that time was after first paint, whereas now we might blocking the browser for about 30-40ms before the first paint (not so bad if XHR finishes after the initial render).</li>\n  <li>If there is a really large number of fonts, we will have to wait for each one of them to download, which might not be desirable. However in that case, we can break up the fonts into multiple batches by calling the <span class=\"tm\">@lemuria/font</span> function multiple times.</li>\n</ol>\n\n<p>\n  On the other hand, the <span class=\"tm\">@lemuria/font</span> script works as a polyfill for <span class=\"tm\">display:swap</span> which is not available for Edge. However, because it embeds fonts with <em>preload</em> links, it will not work on the IE/Edge12-16/Firefox. I thought about downloading fonts with XHR to prime the network cache, however after I downloaded them this way, and then injected the web font stylesheet referencing them, they were re-downloaded. A solution to this would be to embed fonts into the webpage with <span class=\"tm\">data:application/font</span> url, however that would trigger <span class=\"tm\">data:</span> string parsing and slow down the page.\n</p>\n\n<p>\n  <a\n    title=\"Loads A Web Font Stylesheet (e.g., Google Fonts) Without Render Blocking And Multiple Layout Updates.\" class=\"NPMBadge\" href=\"https://npmjs.com/package/@lemuria/font\">\n    <span class=\"a\">@Lemuria/font</span><span class=\"b\">1.0.4</span></a> package is available from NPM, and exports functions that could be added to a server-side rendered webpage. The source code of the function for manual injection can be copied from <a href=\"https://github.com/kumarikandam/font\">Github</a>. The check for <span class=\"tm\">preload</span> support is done the following way, <a target=\"_blank\" rel=\"noopener\" style=\"color: #e33a2c !important; text-decoration: underline;\"\n   href=\"https://www.smashingmagazine.com/2016/02/preload-what-is-it-good-for/\">\n   <img style=\"max-height:1em; margin-right:-0.2em;vertical-align: top;\n        margin-top: .2em;\" alt=\"S\"\n     data-io data-src=\"best-google-font-2/graphics/smashing.png\">\n   <noscript>\n     <img style=\"max-height:1em; margin-right:-0.2em;vertical-align: top;\n          margin-top: .2em;\" alt=\"S\"\n       src=\"best-google-font-2/graphics/smashing.png\">\n   </noscript>uggested by preload</a> contributor to Chrome:\n</p>\n\n<pre id=\"ccdbf4\"><code class=\"javascript hljs\">function DOMTokenListSupports(tokenList, token) {\n  if (!tokenList || !tokenList.supports) {\n    return false\n  } try { return tokenList.supports(token) } catch (e) {\n    return false }\n}\nconst link = document.createElement('link')\nconst linkSupportsPreload = DOMTokenListSupports(link.relList, 'preload')</code></pre>\n\n<p>\n  Finally, the best possible course of action is to preload fonts with a preload link without any scripting. However, that's a different context entirely since this article focuses specifically on <em>Google Fonts</em> optimisation. Their servers will return different urls for different browsers, therefore we can't just copy and paste them in the preload link, additionally their fonts evolve and change versions. The advanced google font loading solution is the simplest scripting solution to kicking off font preload as soon as possible, and eliminate render blocks. Moreover, I was asking myself, does the browser know internally the unicode range of the page even before body is available to JS? The last experiment was to embed the stylesheet manually with a <span class=\"tm\">&lt;style&gt;/* contents of google font stylesheet */&lt;/style&gt;</span> onto the page and see its performance. There are no external resources and the page load should proceed seamlessly from parsing to layout.\n</p>\n\n<pre id=\"c1602\"><code class=\"xml hljs\">&lt;head&gt;\n  &lt;link rel=\"dns-prefetch\" href=\"//fonts.googleapis.com\"&gt;\n  &lt;link rel=\"preconnect\" href=\"https://fonts.gstatic.com\" crossorigin&gt;\n\n  &lt;style&gt;\n    /* latin-ext */\n    @font-face {\n      font-family: 'Gentium Basic';\n      font-style: italic;\n      font-weight: 400;\n      font-display: swap;\n      src: local('Gentium Basic Italic'), local('GentiumBasic-Italic'), url(https://fonts.gstatic.com/s/gentiumbasic/v11/WnzjHAw9aB_JD2VGQVR80We3LAi5hBo7QoCBZCxP.woff2) format('woff2');\n      unicode-range: U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;\n    }\n    /* etc */\n&lt;/style&gt;</code></pre>\n\n</div></div></div>\n<div class=\"container-fluid position-relative mb-3 p-3 rounded\" style=\"overflow: hidden;\">\n  <div class=\" Parallax\" data-loading style=\"z-index: -1;\" id=\"c709f2\"></div>\n  <div style=\"z-index: -1;\" class=\"Parallax\"></div>\n  <noscript>\n    <div class=\" Parallax\" style=\"background-image: url(/img/letters/background.png); z-index: -1;\"></div>\n  </noscript>\n  <p class=\"text-center\">\n    <img alt=\"Embedding contents of a web fonts styles manually.\"\n      src=\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='671' height='522'/%3E\" data-io class=\"border rounded img-fluid\"\n      data-src=\"best-google-font-2/graphics/dev11.gif\">\n    <noscript>\n      <img alt=\"Embedding contents of a web fonts styles manually.\" class=\"border rounded img-fluid\"\n        src=\"best-google-font-2/graphics/dev11.gif\">\n    </noscript>\n  </p>\n  <h5 id=\"figure-4-embedding-contents-of-a-web-fonts-styles-manually\" class=\"m-0 d-inline-block\"\n    style=\"background: white;\">\n    Figure 4: Embedding contents of a web fonts styles manually.\n  </h5>\n</div>\n<div class=\"container\"><div class=\"row\"><div class=\"col\">\n\n<p>\n  The performance graph clearly shows that although urls to fonts are there on the page, they don't begin to download prior to the first style calculation. Therefore, the advanced google font method is even better that what browser can offer natively, because it's able to begin to download fonts even before parsing starts by extracting urls from the stylesheet, if it arrives quickly enough (<a href=\"#2-scenarios\">case A</a>).\n</p>\n\n<p class=\"SectionBreak\">\n  <a title=\"Back To Top\" href=\"#top\">\n    <img alt=\"section break\"\n      src=\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='40' height='13'/%3E\" data-io data-src=\"/section-breaks/1.svg\">\n    <noscript><img alt=\"section break\" src=\"/section-breaks/1.svg\"></noscript></a>\n</p>\n\n<h2 id=\"critical-path-fonts\">Critical Path Fonts</h2>\n\n<p>\n  When marking up a page with strong branded fonts, we don't want users to perceive any font swap, at least not for the first thing they see on a page. The resources required for this first thing are said to lay within the critical path. To achieve instant display of a font, it needs to be added to the page in form of a <span class=\"tm\">data:application/font</span>-encoded base64 string. <em>Google Fonts</em> are not capable of that, therefore it's a completely separate solution, but Google will help us a bit. For example, I want to display the heading \"<span class=\"TM1\">Art </span>\n<span class=\"TM1\">Deco™: </span>\n<span class=\"TM1\">The </span>\n<span class=\"TM1\"><em>Node.JS</em> </span>\n<span class=\"TM1\">Development </span>\n<span class=\"TM1\">Company </span>\n<span class=\"TM1\">In </span>\n<span class=\"TM1\">London</span>\" with the <strong>Limelight</strong> font, therefore I only need these letters to be present. So I call Google to get the font:\n</p>\n\n<pre id=\"c724c\"><code class=\"shell hljs\">chrome:~$ https://fonts.googleapis.com/css?family=Limelight&amp;text= \\\n&gt;  Art Deco™: The Node.JS Development Company In London</code></pre>\n\n<pre id=\"c1d47\"><code class=\"css hljs\">/* the response */\n@font-face {\n  font-family: 'Limelight';\n  font-style: normal;\n  font-weight: 400;\n  src: local('Limelight'),\n       url(https://fonts.gstatic.com/l/font?kit=XLYkIZL7aopJVbZJHDuYOONArnccUFlCcINMXTbYP4QQRwNnyh7l5gk0xNGO3Z9C2lt3&amp;skey=5080ff57360a6ef&amp;v=v10)\n       format('woff2');\n}</code></pre>\n\n<p>\n  I grab the link and download it with Node.JS. It will target only <span class=\"tm\">woff2</span> version because of my user-agent, however I'm not bothered to increase the page size by embedding a <span class=\"tm\">woff</span> font also (for IE).\n</p>\n\n<pre id=\"ccdbf5\"><code class=\"javascript hljs\">const format = 'woff2'\nconst body = await aqt(link, {\n  binary: true,\n})\nconst base = body.toString('base64')\nconst data = `data:application/font-${format};base64,${base}`</code></pre>\n\n<p>\n  After the data string is constructed, I can upgrade the stylesheet to include this string instead of the url.\n</p>\n\n<pre id=\"c16021\"><code class=\"xml hljs\">&lt;head&gt;\n  &lt;style&gt;\n    @font-face {\n      font-family: 'Limelight';\n      font-style: normal;\n      font-weight: 400;\n      font-display: 'block';\n      src: local('Limelight'),\n           url('data:application/font-woff2;base64,d09GMgABAAAAAAmYAAwAAAAAEAAAAAlKAAEA...=')\n           format('woff2');\n    }\n    h1 {\n      font-family: 'Limelight';\n    }\n  &lt;/style&gt;\n&lt;/head&gt;</code></pre>\n\n<p>\n  If I refresh the page, depending on the <span class=\"tm\">font-display</span>, I will either witness a FOUT, or a <abbr title=\"Flash of Invisible Text\">FOIT</abbr>. But if I've injected the font into the .html document, shouldn't this not be the case? The problem is that even though the font was embedded with a <span class=\"tm\">data</span> url, it too has to load via the network, as seen in the performance graph below.\n</p>\n\n</div></div></div>\n<div class=\"container-fluid position-relative mb-3 p-3 rounded\" style=\"overflow: hidden;\"\n  id=\"fig-data-url\">\n  <div class=\" Parallax\" data-loading style=\"z-index: -1;\" id=\"c709f3\"></div>\n  <div style=\"z-index: -1;\" class=\"Parallax\"></div>\n  <noscript>\n    <div class=\" Parallax\" style=\"background-image: url(/img/letters/background.png); z-index: -1;\"></div>\n  </noscript>\n  <p class=\"text-center\">\n    <img alt=\"Data-url embedded font also takes time to download.\"\n      src=\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='671' height='522'/%3E\" data-io class=\"border rounded img-fluid\"\n      data-src=\"best-google-font-2/graphics/dev13.gif\">\n    <noscript>\n      <img alt=\"Data-url embedded font also takes time to download.\" class=\"border rounded img-fluid\"\n        src=\"best-google-font-2/graphics/dev13.gif\">\n    </noscript>\n  </p>\n  <h5 id=\"figure-5-data-url-embedded-font-also-takes-time-to-download\" class=\"m-0 d-inline-block\"\n    style=\"background: white;\">\n    Figure 5: Data-url embedded font also takes time to download.\n  </h5>\n</div>\n<div class=\"container\"><div class=\"row\"><div class=\"col\">\n\n<p>\n  This result is consistent with the previous experiment, where I've shown that fonts, even declared in a <span class=\"tm\">style</span> tag and not in an external stylesheet, begin to download only when it comes to first <span style=\"background:#a66eeb;\">Recalculate styles</span> job (misleading called <em>RE</em>calculate, it's actually calculate). Here, after the font's download is finished, it forces a reflow and blocks the page for 100ms. It's really not good enough for an advanced optimisation. I'll apply the preload link on the font encoded with into <span class=\"tm\">data:</span> string to solve this problem. I'll use the <span class=\"tm\">onload</span> attribute to get reference to the base64-encoded data so that I don't have to declare it twice (first in the preload link, and second time in the style).\n</p>\n\n<pre id=\"cbdf7\"><code class=\"xml hljs\">&lt;head&gt;\n  &lt;link\n    href=\"data:application/font-woff2;base64,d09GMgABAAAAAAmYAAwAAAAAEAAAAAlKAAEAAAAAAAAAAAAAAAAAAAAAAAAAAA...\"\n    rel=\"preload\" as=\"font\"\n    onload=\"performance.mark('a');window._fontLoaded(this);\n      setTimeout(() =&gt; performance.measure('data font', 'a'), 100)\"&gt;\n\n  &lt;script&gt;\n    window._fontLoaded = function(linkEl) {\n      var data = linkEl.href\n      var s = document.createElement('style')\n      s.innerText = \"@font-face {  font-family: 'Limelight';  font-style: normal;  font-weight: 400;  src: local('Limelight'), url('_URL') format('woff2');}h1 { font-family: 'Limelight' }\".replace('_URL', data)\n      document.head.appendChild(s)\n    }\n  &lt;/script&gt;\n  &lt;!-- a polyfill for when JS is disabled --&gt;\n  &lt;noscript&gt;\n    &lt;link\n      href=\"https://fonts.googleapis.com/css?family=Limelight&amp;amp;text=Art%20Deco%E2%84%A2%3A%20The%20Node.JS%20Development%20Company%20In%20London\" rel=\"stylesheet\"&gt;\n    &lt;style&gt;h1 { font-family: 'Limelight' }&lt;/style&gt;\n  &lt;/noscript&gt;\n&lt;/head&gt;</code></pre>\n\n<p>\n  We <strong>must not</strong> set the <span class=\"tm\">crossorigin</span> attribute on the link, as <em>Safari</em> will error on it, saying the host didn't provide a CORS header. In case the <strong>preload</strong> <em>rel</em> is not supported, the polyfill can be used, which just calls the <span class=\"tm\">onload</span> method. The <span class=\"tm\">Symbol.iterator</span> polyfill inserted by Closure Compiler (because I did <span class=\"tm\">[...document.head.querySelectorAll('[rel=&quot;preload&quot;][onload]')]</span>) is a bit long but I can't be bothered to do something like <span class=\"tm\">[].forEach.call</span> or whatever other way there is.\n</p>\n\n<pre id=\"c6ce53\"><code class=\"xml hljs\">&lt;script&gt;\n  (function(){function b(){var a=c,g=0;return function(){return g&lt;a.length?{done:!1,value:a[g++]}:{done:!0}}}var d;var e=document.createElement(\"link\").relList;if(e&amp;&amp;e.supports)try{d=e.supports(\"preload\")}catch(a){d=!1}else d=!1;if(!d){var f=document.head.querySelectorAll('[rel=\"preload\"][onload]'),h;\n  if(f instanceof Array)h=f;else{var k,c=f,l=\"undefined\"!=typeof Symbol&amp;&amp;Symbol.iterator&amp;&amp;c[Symbol.iterator];k=l?l.call(c):{next:b()};for(var m,n=[];!(m=k.next()).done;)n.push(m.value);h=n}h.concat().forEach(function(a){if(a.onload)a.onload(a)})};}).call(this);\n&lt;/script&gt;</code></pre>\n\n</div></div></div>\n<div class=\"container-fluid position-relative mb-3 p-3 rounded\" style=\"overflow: hidden;\">\n  <div class=\" Parallax\" data-loading style=\"z-index: -1;\" id=\"c709f4\"></div>\n  <div style=\"z-index: -1;\" class=\"Parallax\"></div>\n  <noscript>\n    <div class=\" Parallax\" style=\"background-image: url(/img/letters/background.png); z-index: -1;\"></div>\n  </noscript>\n  <p class=\"text-center\">\n    <img alt=\"Achieving critical path font without FOUT/FOIT.\"\n      src=\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='671' height='522'/%3E\" data-io class=\"border rounded img-fluid\"\n      data-src=\"best-google-font-2/graphics/dev14.gif\">\n    <noscript>\n      <img alt=\"Achieving critical path font without FOUT/FOIT.\" class=\"border rounded img-fluid\"\n        src=\"best-google-font-2/graphics/dev14.gif\">\n    </noscript>\n  </p>\n  <h5 id=\"figure-6-achieving-critical-path-font-without-foutfoit\" class=\"m-0 d-inline-block\"\n    style=\"background: white;\">\n    Figure 6: Achieving critical path font without FOUT/FOIT.\n  </h5>\n</div>\n<div class=\"container\"><div class=\"row\"><div class=\"col\">\n\n<p>\n  And that's how I got my page opening with the font already present. Unlike in the usual <span class=\"tm\">＜style＞</span> approach with a base64-encoded font in it, here the text is drawn immediately using the font face that I specified, as it was loaded before the initial render. Compare how <a href=\"#fig-data-url\">previously</a>, the font started do download (grey bar) only during the recalculate styles stage, whereas now, it loads as soon as HTML starts parsing. However, it's still not as great as a style preload, which begins even before parsing. There's no way to set a different attribute on the link, like <span class=\"tm\">fetch</span>, load it with XHR and then embed onto the page, because that would lead to another download. But to be honest, I cheated a little bit in this last case, did you notice how? I included an external stylesheet, my <span class=\"tm\">combined.css</span> which slowed down the first render, giving the <span class=\"tm\">data:</span> url a chance to load.\n</p>\n\n<p>\n  [i] <em>The performance timing shows that the preload event fired before the layout, but although it's duration is set to 100ms in code, it took 276ms to complete, which proves that the thread was blocked.</em>\n</p>\n\n<p>\n  If I embed the <span class=\"tm\">combined.css</span> stylesheet and eliminate this render-blocking resource, I'll loose the gained advantage:\n</p>\n\n</div></div></div>\n<div class=\"container-fluid position-relative mb-3 p-3 rounded\" style=\"overflow: hidden;\">\n  <div class=\" Parallax\" data-loading style=\"z-index: -1;\" id=\"c709f5\"></div>\n  <div style=\"z-index: -1;\" class=\"Parallax\"></div>\n  <noscript>\n    <div class=\" Parallax\" style=\"background-image: url(/img/letters/background.png); z-index: -1;\"></div>\n  </noscript>\n  <p class=\"text-center\">\n    <img alt=\"Waiting for onload event to fire on preload link.\"\n      src=\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='671' height='522'/%3E\" data-io class=\"border rounded img-fluid\"\n      data-src=\"best-google-font-2/graphics/dev15.gif\">\n    <noscript>\n      <img alt=\"Waiting for onload event to fire on preload link.\" class=\"border rounded img-fluid\"\n        src=\"best-google-font-2/graphics/dev15.gif\">\n    </noscript>\n  </p>\n  <h5 id=\"figure-7-waiting-for-onload-event-to-fire-on-preload-link\" class=\"m-0 d-inline-block\"\n    style=\"background: white;\">\n    Figure 7: Waiting for onload event to fire on preload link.\n  </h5>\n</div>\n<div class=\"container\"><div class=\"row\"><div class=\"col\">\n\n<p>\n  On a fast page, the font in the preload link completes its loading process only when the layout began, and the main thread is blocked. We have to wait for the thread to clear after which the <span class=\"tm\">onload</span> event will fire. This cancels out the benefit of preloading the font. So what do we do? I thought of splitting the font into 3 preload links, and loading them in parallel, however that seems too complicated, and also too relies on the <span class=\"tm\">onload</span> attribute which is inefficient since there's always a risk of running into the main thread block. What worked was not using the <span class=\"tm\">onload</span> at all, and repeating font's data-url string both in the stylesheet and in the preload link. If the font is only 2kb, I don't mind making it 4kb for superb user experience that could land me a client.\n</p>\n\n</div></div></div>\n<div class=\"container-fluid position-relative mb-3 p-3 rounded\" style=\"overflow: hidden;\">\n  <div class=\" Parallax\" data-loading style=\"z-index: -1;\" id=\"c709f6\"></div>\n  <div style=\"z-index: -1;\" class=\"Parallax\"></div>\n  <noscript>\n    <div class=\" Parallax\" style=\"background-image: url(/img/letters/background.png); z-index: -1;\"></div>\n  </noscript>\n  <p class=\"text-center\">\n    <img alt=\"Preloading data-url font used in stylesheet leads to the best optimisation.\"\n      src=\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='671' height='522'/%3E\" data-io class=\"border rounded img-fluid\"\n      data-src=\"best-google-font-2/graphics/dev16.gif\">\n    <noscript>\n      <img alt=\"Preloading data-url font used in stylesheet leads to the best optimisation.\"\n        class=\"border rounded img-fluid\" src=\"best-google-font-2/graphics/dev16.gif\">\n    </noscript>\n  </p>\n  <h5 id=\"figure-8-preloading-data-url-font-used-in-stylesheet-leads-to-the-best-optimisation\"\n    class=\"m-0 d-inline-block\" style=\"background: white;\">\n    Figure 8: Preloading data-url font used in stylesheet leads to the best optimisation.\n  </h5>\n</div>\n<div class=\"container\"><div class=\"row\"><div class=\"col\">\n\n<p class=\"SectionBreak\">\n  <a title=\"Back To Top\" href=\"#top\">\n    <img alt=\"section break\"\n      src=\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='40' height='13'/%3E\" data-io data-src=\"/section-breaks/2.svg\">\n    <noscript><img alt=\"section break\" src=\"/section-breaks/2.svg\"></noscript></a>\n</p>\n\n\n<p>\n  Say, someone is looking to develop a web page, they click a link to my website, and instantly they see a page that is branded with a font and opens in a split second. Would they be impressed? I think so. In other industries the value of extremely fast loading is probably more subtle and rests on the subconscious appreciation of an aesthetically pleasing fast website. But then again, optimisations like this are only the final polishing steps in producing an amazing website, that above all has impressive design and meaningful and engaging content. Still, here I'm describing it in such details because it helps to understand how browsers work so that we can apply this knowledge (rather than a specific method) in all of our work.\n</p>\n</div>\n  </div>\n</div>\n",
  "file": "./best-google-font-2",
  "postAjax": "(function imgPostAjax() {\n  /* eslint-env browser */\n  window['IO']()\n  window['WEBP']()\n})()"
}