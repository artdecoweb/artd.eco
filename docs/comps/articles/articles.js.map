{
  "version": 3,
  "file": "docs/comps/articles/articles.js",
  "lineCount": 2,
  "mappings": "AAgDOA,QAASA,GAAU,CAACC,CAAD,CAAOC,CAAP,CAAaC,CAAb,CAAmBC,CAAnB,CAAuBC,CAAvB,CAA+BC,CAA/B,CAAsCC,CAAtC,CAAgD,CAE9DC,QAAA,EAAA,EAAM,CACdL,CAAAM,OAAA,CAAY,MAAA,OAAA,CAAA,EAAA,CAAKH,CAAL,CAAA,CAAYC,SAAAA,CAAZ,CAAA,CAAZ,CACAN,EAAAS,SAAA,CAAgBP,CAFF,CADXA,CAAL,GAAWA,CAAX,CAAkB,IAAID,CAAJ,CAASE,CAAT,CAAaC,CAAb,CAAlB,CAKIH,EAAAS,KAAJ,CACET,CAAAS,KAAA,CAAU,QAAA,CAACC,CAAD,CAAMC,CAAN,CAAe,CACnBA,CAAJ,EAAUC,MAAAC,OAAA,CAAcT,CAAd,CAAqBO,CAArB,CACLD,EAAL,CACKI,OAAAC,KAAA,CAAaL,CAAb,CADL,CAAUJ,CAAA,EAFa,CAAzB,CAIGJ,CAJH,CAIOE,CAJP,CADF,CAMOE,CAAA,EACP,OAAOL,EAbiE,CC7C1E,IAAMe,GAAa,EACnBC,EAAA,EAIA,KAAMC,GAAe,CACnB,SAAYC,CADO,CAArB,CAIMC,GAAKC,CAAA,EAEEtB;CAAC,CACZuB,IAAK,UADO,CAEZC,GAAI,OAFQ,CAGZnB,MAAO,CACL,mBAAoB,eADf,CAHK,CAADL,CAObyB,QAAA,CAAa,QAAA,CAAC,CAAD,CAA4C,CAAzC,IAAAF,EAAF,CAAE,IAAA,CAAKC,EAAP,CAAO,GAAL,CAASnB,EAAA,IAAA,EAAA,GAAX,CAAW,MAAA,CAAQ,EAAR,CAAX,CAAW,MAAT,CAAqBC,EAAA,IAAA,EAAA,GAAvB,CAAuB,SAAA,CAAW,EAAX,CAAvB,CAAuB,SAArB,CACRL,EAAOkB,EAAA,CAAaI,CAAb,CAEblB,EAAAqB,EAAA,CAAiB,CAAE,EAAAC,QAAM,CAACC,CAAD,CAAa,CACpC,MAAOC,EAAA,CAAgBZ,EAAA,CAAWW,CAAX,CAAhB,CAD6B,CAArB,CAILJ,EAAAM,MAAAC,CAAS,GAATA,CACZN,QAAA,CAAY,QAAA,CAACO,CAAD,CAAQ,CACZ,IAAA,EAAiBC,CAAA,CAAKD,CAAL,CAAST,CAAT,CAAjB,CAAEnB,EAAA,CAAA,OAAF,CAAUD,EAAA,CAAA,EAAV,CACA+B,EAAmD,CAAEX,IAAAA,CAAF,CAAOC,GAAIQ,CAAX,CAAeG,MAR5DA,CAAAA,CAQ6C,CADnD,CAEFjC,CACJC,EAAAK,OAAA,CAAY4B,QAAA,EAAM,CAEhB,MADAlC,EACA,CADOH,EAAA,CAAWmC,CAAX,CAAuBjC,CAAvB,CAA6BC,CAA7B,CAAmCC,CAAnC,CAAuCC,CAAvC,CAA+CC,CAA/C,CAAsDC,CAAtD,CADS,CAIlBH,EAAAK,OAAAR,EAAA,CAAiBkC,CACjBb,GAAAgB,QAAA,CAAWlC,CAAX,CATkB,CAApB,CARuD,CAAzD;",
  "sources": [
    "/splendid/comps/__competent-lib.js",
    "/splendid/comps/articles/articles.js"
  ],
  "sourcesContent": [
    "export function init(id, key) {\n  const el = document.getElementById(id)\n  if (!el) {\n    console.warn('Parent element for component %s with id %s not found', key, id)\n    return {}\n  }\n  const parent = el.parentElement\n  if (!parent) {\n    console.warn('Parent of element for component %s with id %s not found', key, id)\n    return {}\n  }\n  return { parent, el  }\n}\n\nexport function makeIo(options = {}) {\n  const { rootMargin = '76px', log = true, ...rest } = options\n  const io = new IntersectionObserver((entries) => {\n    entries.forEach(({ target, isIntersecting }) => {\n      /**\n       * @type {_competent.RenderMeta}\n       */\n      const meta = target.render.meta\n      const { key, id, plain } = meta\n      if (isIntersecting) {\n        if (log)\n          console.warn('🏗 Rendering%s component %s into the element %s',\n            !plain ? ' Preact' : '', key, id, target)\n        try {\n          const instance = target.render()\n          if (instance && !instance.unrender) io.unobserve(target) // plain\n        } catch (err) {\n          if (log) console.warn(err)\n        }\n      } else if (meta.instance) {\n        if (log)\n          console.warn('💨 Unrendering%s component %s from the element %s',\n            !plain ? ' Preact' : '', key, id, target)\n        meta.instance.unrender()\n      }\n    })\n  }, { rootMargin, ...rest })\n  return io\n}\n\n/**\n * @param {_competent.RenderMeta} meta\n * @param {function(new:_competent.PlainComponent, Element, Element)} Comp\n */\nexport function startPlain(meta, Comp, comp, el, parent, props, children) {\n  if (!comp) comp = new Comp(el, parent)\n  const r = () => {\n    comp.render({ ...props, children })\n    meta.instance = comp\n  }\n  if (Comp.load) { // &!comp\n    Comp.load((err, data) => {\n      if (data) Object.assign(props, data)\n      if (!err) r()\n      else console.warn(err)\n    }, el, props)\n  } else r()\n  return comp\n}\n\n/**\n * @param {_competent.RenderMeta} meta\n */\nexport function start(meta, Comp, comp, el, parent, props, children, preact) {\n  const { render, h } = preact\n  const isPlain = meta.plain\n  if (!comp && isPlain) {\n    comp = new Comp(el, parent)\n  }\n  const r = () => {\n    if (isPlain) {\n      comp.render({ ...props, children })\n      meta.instance = comp\n    } else render(h(Comp, props, children), parent, el)\n  }\n  if (Comp.load) {\n    Comp.load((err, data) => {\n      if (data) Object.assign(props, data)\n      if (!err) r()\n      else console.warn(err)\n    }, el, props)\n  } else r()\n  return comp\n}",
    "import __initBottom from '../__init/bottom'\nimport '../../js/load-background-img'\nimport makeClassGetter from '../__mcg'\nconst renameMaps = {  }\n__initBottom()\nimport { makeIo, init, startPlain } from '../__competent-lib'\nimport Parallax from '../../../node_modules/splendid/src/components/parallax'\n\nconst __components = {\n  'parallax': Parallax,\n}\n\nconst io = makeIo()\n\nconst meta = [{\n  key: 'parallax',\n  id: 'c5471',\n  props: {\n    'background-image': '/img/tile.jpg',\n  },\n}]\nmeta.forEach(({ key, id, props = {}, children = [] }) => {\n  const Comp = __components[key]\n  const plain = true\n  props.splendid = { addCSS(stylesheet) {\n    return makeClassGetter(renameMaps[stylesheet])\n  } }\n\n  const ids = id.split(',')\n  ids.forEach((Id) => {\n    const { parent, el } = init(Id, key)\n    const renderMeta = /** @type {_competent.RenderMeta} */ ({ key, id: Id, plain })\n    let comp\n    el.render = () => {\n      comp = startPlain(renderMeta, Comp, comp, el, parent, props, children)\n      return comp\n    }\n    el.render.meta = renderMeta\n    io.observe(el)\n  })\n})\n"
  ],
  "names": [
    "startPlain",
    "meta",
    "Comp",
    "comp",
    "el",
    "parent",
    "props",
    "children",
    "r",
    "render",
    "instance",
    "load",
    "err",
    "data",
    "Object",
    "assign",
    "console",
    "warn",
    "renameMaps",
    "__initBottom",
    "__components",
    "Parallax",
    "io",
    "makeIo",
    "key",
    "id",
    "forEach",
    "splendid",
    "addCSS",
    "stylesheet",
    "makeClassGetter",
    "split",
    "ids",
    "Id",
    "init",
    "renderMeta",
    "plain",
    "el.render",
    "observe"
  ]
}