{
"version":3,
"file":"docs/js/io.js",
"lineCount":9,
"mappings":"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",
"sources":["splendid/js/io.js"],
"sourcesContent":["/* eslint-env browser */\n/**\n * Copyright 2016 Google Inc. All Rights Reserved.\n *\n * Licensed under the W3C SOFTWARE AND DOCUMENT NOTICE AND LICENSE.\n *\n *  https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document\n *\n */\n(function() {\n  'use strict'\n\n  // Exit early if we're not running in a browser.\n  if (typeof window !== 'object') {\n    return\n  }\n\n  // Exit early if all IntersectionObserver and IntersectionObserverEntry\n  // features are natively supported.\n  if ('IntersectionObserver' in window &&\n      'IntersectionObserverEntry' in window &&\n      'intersectionRatio' in window.IntersectionObserverEntry.prototype) {\n    // Minimal polyfill for Edge 15's lack of `isIntersecting`\n    // See: https://github.com/w3c/IntersectionObserver/issues/211\n    if (!('isIntersecting' in window.IntersectionObserverEntry.prototype)) {\n      Object.defineProperty(window.IntersectionObserverEntry.prototype,\n        'isIntersecting', {\n          get: function () {\n            return this.intersectionRatio > 0\n          },\n        })\n    }\n    return\n  }\n\n\n  /**\n   * A local reference to the document.\n   */\n  var document = window.document\n\n\n  /**\n   * An IntersectionObserver registry. This registry exists to hold a strong\n   * reference to IntersectionObserver instances currently observing a target\n   * element. Without this registry, instances without another reference may be\n   * garbage collected.\n   */\n  var registry = []\n\n\n  /**\n   * Creates the global IntersectionObserverEntry constructor.\n   * https://w3c.github.io/IntersectionObserver/#intersection-observer-entry\n   * @param {Object} entry A dictionary of instance properties.\n   * @constructor\n   */\n  function IntersectionObserverEntry(entry) {\n    this.time = entry.time\n    this.target = entry.target\n    this.rootBounds = entry.rootBounds\n    this.boundingClientRect = entry.boundingClientRect\n    this.intersectionRect = entry.intersectionRect || getEmptyRect()\n    this.isIntersecting = !!entry.intersectionRect\n\n    // Calculates the intersection ratio.\n    var targetRect = this.boundingClientRect\n    var targetArea = targetRect.width * targetRect.height\n    var intersectionRect = this.intersectionRect\n    var intersectionArea = intersectionRect.width * intersectionRect.height\n\n    // Sets intersection ratio.\n    if (targetArea) {\n      // Round the intersection ratio to avoid floating point math issues:\n      // https://github.com/w3c/IntersectionObserver/issues/324\n      this.intersectionRatio = Number((intersectionArea / targetArea).toFixed(4))\n    } else {\n      // If area is zero and is intersecting, sets to 1, otherwise to 0\n      this.intersectionRatio = this.isIntersecting ? 1 : 0\n    }\n  }\n\n\n  /**\n   * Creates the global IntersectionObserver constructor.\n   * https://w3c.github.io/IntersectionObserver/#intersection-observer-interface\n   * @param {Function} callback The function to be invoked after intersection\n   *     changes have queued. The function is not invoked if the queue has\n   *     been emptied by calling the `takeRecords` method.\n   * @param {Object=} opt_options Optional configuration options.\n   * @constructor\n   */\n  function IntersectionObserver(callback, opt_options) {\n    var options = opt_options || {}\n\n    if (typeof callback != 'function') {\n      throw new Error('callback must be a function')\n    }\n\n    if (options.root && options.root.nodeType != 1) {\n      throw new Error('root must be an Element')\n    }\n\n    // Binds and throttles `this._checkForIntersections`.\n    this._checkForIntersections = throttle(\n      this._checkForIntersections.bind(this), this.THROTTLE_TIMEOUT)\n\n    // Private properties.\n    this._callback = callback\n    this._observationTargets = []\n    this._queuedEntries = []\n    this._rootMarginValues = this._parseRootMargin(options.rootMargin)\n\n    // Public properties.\n    this.thresholds = this._initThresholds(options.threshold)\n    this.root = options.root || null\n    this.rootMargin = this._rootMarginValues.map(function(margin) {\n      return margin.value + margin.unit\n    }).join(' ')\n  }\n\n\n  /**\n   * The minimum interval within which the document will be checked for\n   * intersection changes.\n   */\n  IntersectionObserver.prototype.THROTTLE_TIMEOUT = 100\n\n\n  /**\n   * The frequency in which the polyfill polls for intersection changes.\n   * this can be updated on a per instance basis and must be set prior to\n   * calling `observe` on the first target.\n   */\n  IntersectionObserver.prototype.POLL_INTERVAL = null\n\n  /**\n   * Use a mutation observer on the root element\n   * to detect intersection changes.\n   */\n  IntersectionObserver.prototype.USE_MUTATION_OBSERVER = true\n\n\n  /**\n   * Starts observing a target element for intersection changes based on\n   * the thresholds values.\n   * @param {Element} target The DOM element to observe.\n   */\n  IntersectionObserver.prototype.observe = function(target) {\n    var isTargetAlreadyObserved = this._observationTargets.some(function(item) {\n      return item.element == target\n    })\n\n    if (isTargetAlreadyObserved) {\n      return\n    }\n\n    if (!(target && target.nodeType == 1)) {\n      throw new Error('target must be an Element')\n    }\n\n    this._registerInstance()\n    this._observationTargets.push({ element: target, entry: null })\n    this._monitorIntersections()\n    this._checkForIntersections()\n  }\n\n\n  /**\n   * Stops observing a target element for intersection changes.\n   * @param {Element} target The DOM element to observe.\n   */\n  IntersectionObserver.prototype.unobserve = function(target) {\n    this._observationTargets =\n        this._observationTargets.filter(function(item) {\n          return item.element != target\n        })\n    if (!this._observationTargets.length) {\n      this._unmonitorIntersections()\n      this._unregisterInstance()\n    }\n  }\n\n\n  /**\n   * Stops observing all target elements for intersection changes.\n   */\n  IntersectionObserver.prototype.disconnect = function() {\n    this._observationTargets = []\n    this._unmonitorIntersections()\n    this._unregisterInstance()\n  }\n\n\n  /**\n   * Returns any queue entries that have not yet been reported to the\n   * callback and clears the queue. This can be used in conjunction with the\n   * callback to obtain the absolute most up-to-date intersection information.\n   * @return {Array} The currently queued entries.\n   */\n  IntersectionObserver.prototype.takeRecords = function() {\n    var records = this._queuedEntries.slice()\n    this._queuedEntries = []\n    return records\n  }\n\n\n  /**\n   * Accepts the threshold value from the user configuration object and\n   * returns a sorted array of unique threshold values. If a value is not\n   * between 0 and 1 and error is thrown.\n   * @private\n   * @param {Array|number=} opt_threshold An optional threshold value or\n   *     a list of threshold values, defaulting to [0].\n   * @return {Array} A sorted list of unique and valid threshold values.\n   */\n  IntersectionObserver.prototype._initThresholds = function(opt_threshold) {\n    var threshold = opt_threshold || [0]\n    if (!Array.isArray(threshold)) threshold = [threshold]\n\n    return threshold.sort().filter(function(t, i, a) {\n      if (typeof t != 'number' || isNaN(t) || t < 0 || t > 1) {\n        throw new Error('threshold must be a number between 0 and 1 inclusively')\n      }\n      return t !== a[i - 1]\n    })\n  }\n\n\n  /**\n   * Accepts the rootMargin value from the user configuration object\n   * and returns an array of the four margin values as an object containing\n   * the value and unit properties. If any of the values are not properly\n   * formatted or use a unit other than px or %, and error is thrown.\n   * @private\n   * @param {string=} opt_rootMargin An optional rootMargin value,\n   *     defaulting to '0px'.\n   * @return {Array<Object>} An array of margin objects with the keys\n   *     value and unit.\n   */\n  IntersectionObserver.prototype._parseRootMargin = function(opt_rootMargin) {\n    var marginString = opt_rootMargin || '0px'\n    var margins = marginString.split(/\\s+/).map(function(margin) {\n      var parts = /^(-?\\d*\\.?\\d+)(px|%)$/.exec(margin)\n      if (!parts) {\n        throw new Error('rootMargin must be specified in pixels or percent')\n      }\n      return { value: parseFloat(parts[1]), unit: parts[2] }\n    })\n\n    // Handles shorthand.\n    margins[1] = margins[1] || margins[0]\n    margins[2] = margins[2] || margins[0]\n    margins[3] = margins[3] || margins[1]\n\n    return margins\n  }\n\n\n  /**\n   * Starts polling for intersection changes if the polling is not already\n   * happening, and if the page's visibility state is visible.\n   * @private\n   */\n  IntersectionObserver.prototype._monitorIntersections = function() {\n    if (!this._monitoringIntersections) {\n      this._monitoringIntersections = true\n\n      // If a poll interval is set, use polling instead of listening to\n      // resize and scroll events or DOM mutations.\n      if (this.POLL_INTERVAL) {\n        this._monitoringInterval = setInterval(\n          this._checkForIntersections, this.POLL_INTERVAL)\n      }\n      else {\n        addEvent(window, 'resize', this._checkForIntersections, true)\n        addEvent(document, 'scroll', this._checkForIntersections, true)\n\n        if (this.USE_MUTATION_OBSERVER && 'MutationObserver' in window) {\n          this._domObserver = new MutationObserver(this._checkForIntersections)\n          this._domObserver.observe(document, {\n            attributes: true,\n            childList: true,\n            characterData: true,\n            subtree: true,\n          })\n        }\n      }\n    }\n  }\n\n\n  /**\n   * Stops polling for intersection changes.\n   * @private\n   */\n  IntersectionObserver.prototype._unmonitorIntersections = function() {\n    if (this._monitoringIntersections) {\n      this._monitoringIntersections = false\n\n      clearInterval(this._monitoringInterval)\n      this._monitoringInterval = null\n\n      removeEvent(window, 'resize', this._checkForIntersections, true)\n      removeEvent(document, 'scroll', this._checkForIntersections, true)\n\n      if (this._domObserver) {\n        this._domObserver.disconnect()\n        this._domObserver = null\n      }\n    }\n  }\n\n\n  /**\n   * Scans each observation target for intersection changes and adds them\n   * to the internal entries queue. If new entries are found, it\n   * schedules the callback to be invoked.\n   * @private\n   */\n  IntersectionObserver.prototype._checkForIntersections = function() {\n    var rootIsInDom = this._rootIsInDom()\n    var rootRect = rootIsInDom ? this._getRootRect() : getEmptyRect()\n\n    this._observationTargets.forEach(function(item) {\n      var target = item.element\n      var targetRect = getBoundingClientRect(target)\n      var rootContainsTarget = this._rootContainsTarget(target)\n      var oldEntry = item.entry\n      var intersectionRect = rootIsInDom && rootContainsTarget &&\n          this._computeTargetAndRootIntersection(target, rootRect)\n\n      var newEntry = item.entry = new IntersectionObserverEntry({\n        time: now(),\n        target: target,\n        boundingClientRect: targetRect,\n        rootBounds: rootRect,\n        intersectionRect: intersectionRect,\n      })\n\n      if (!oldEntry) {\n        this._queuedEntries.push(newEntry)\n      } else if (rootIsInDom && rootContainsTarget) {\n        // If the new entry intersection ratio has crossed any of the\n        // thresholds, add a new entry.\n        if (this._hasCrossedThreshold(oldEntry, newEntry)) {\n          this._queuedEntries.push(newEntry)\n        }\n      } else {\n        // If the root is not in the DOM or target is not contained within\n        // root but the previous entry for this target had an intersection,\n        // add a new record indicating removal.\n        if (oldEntry && oldEntry.isIntersecting) {\n          this._queuedEntries.push(newEntry)\n        }\n      }\n    }, this)\n\n    if (this._queuedEntries.length) {\n      this._callback(this.takeRecords(), this)\n    }\n  }\n\n\n  /**\n   * Accepts a target and root rect computes the intersection between then\n   * following the algorithm in the spec.\n   * TODO(philipwalton): at this time clip-path is not considered.\n   * https://w3c.github.io/IntersectionObserver/#calculate-intersection-rect-algo\n   * @param {Element} target The target DOM element\n   * @param {Object} rootRect The bounding rect of the root after being\n   *     expanded by the rootMargin value.\n   * @return {?Object} The final intersection rect object or undefined if no\n   *     intersection is found.\n   * @private\n   */\n  IntersectionObserver.prototype._computeTargetAndRootIntersection =\n      function(target, rootRect) {\n        // If the element isn't displayed, an intersection can't happen.\n        if (window.getComputedStyle(target).display == 'none') return\n\n        var targetRect = getBoundingClientRect(target)\n        var intersectionRect = targetRect\n        var parent = getParentNode(target)\n        var atRoot = false\n\n        while (!atRoot) {\n          var parentRect = null\n          var parentComputedStyle = parent.nodeType == 1 ?\n            window.getComputedStyle(parent) : {}\n\n          // If the parent isn't displayed, an intersection can't happen.\n          if (parentComputedStyle.display == 'none') return\n\n          if (parent == this.root || parent == document) {\n            atRoot = true\n            parentRect = rootRect\n          } else {\n            // If the element has a non-visible overflow, and it's not the <body>\n            // or <html> element, update the intersection rect.\n            // Note: <body> and <html> cannot be clipped to a rect that's not also\n            // the document rect, so no need to compute a new intersection.\n            if (parent != document.body &&\n            parent != document.documentElement &&\n            parentComputedStyle.overflow != 'visible') {\n              parentRect = getBoundingClientRect(parent)\n            }\n          }\n\n          // If either of the above conditionals set a new parentRect,\n          // calculate new intersection data.\n          if (parentRect) {\n            intersectionRect = computeRectIntersection(parentRect, intersectionRect)\n\n            if (!intersectionRect) break\n          }\n          parent = getParentNode(parent)\n        }\n        return intersectionRect\n      }\n\n\n  /**\n   * Returns the root rect after being expanded by the rootMargin value.\n   * @return {Object} The expanded root rect.\n   * @private\n   */\n  IntersectionObserver.prototype._getRootRect = function() {\n    var rootRect\n    if (this.root) {\n      rootRect = getBoundingClientRect(this.root)\n    } else {\n      // Use <html>/<body> instead of window since scroll bars affect size.\n      var html = document.documentElement\n      var body = document.body\n      rootRect = {\n        top: 0,\n        left: 0,\n        right: html.clientWidth || body.clientWidth,\n        width: html.clientWidth || body.clientWidth,\n        bottom: html.clientHeight || body.clientHeight,\n        height: html.clientHeight || body.clientHeight,\n      }\n    }\n    return this._expandRectByRootMargin(rootRect)\n  }\n\n\n  /**\n   * Accepts a rect and expands it by the rootMargin value.\n   * @param {Object} rect The rect object to expand.\n   * @return {Object} The expanded rect.\n   * @private\n   */\n  IntersectionObserver.prototype._expandRectByRootMargin = function(rect) {\n    var margins = this._rootMarginValues.map(function(margin, i) {\n      return margin.unit == 'px' ? margin.value :\n        margin.value * (i % 2 ? rect.width : rect.height) / 100\n    })\n    var newRect = {\n      top: rect.top - margins[0],\n      right: rect.right + margins[1],\n      bottom: rect.bottom + margins[2],\n      left: rect.left - margins[3],\n    }\n    newRect.width = newRect.right - newRect.left\n    newRect.height = newRect.bottom - newRect.top\n\n    return newRect\n  }\n\n\n  /**\n   * Accepts an old and new entry and returns true if at least one of the\n   * threshold values has been crossed.\n   * @param {?IntersectionObserverEntry} oldEntry The previous entry for a\n   *    particular target element or null if no previous entry exists.\n   * @param {IntersectionObserverEntry} newEntry The current entry for a\n   *    particular target element.\n   * @return {boolean} Returns true if a any threshold has been crossed.\n   * @private\n   */\n  IntersectionObserver.prototype._hasCrossedThreshold =\n      function(oldEntry, newEntry) {\n        // To make comparing easier, an entry that has a ratio of 0\n        // but does not actually intersect is given a value of -1\n        var oldRatio = oldEntry && oldEntry.isIntersecting ?\n          oldEntry.intersectionRatio || 0 : -1\n        var newRatio = newEntry.isIntersecting ?\n          newEntry.intersectionRatio || 0 : -1\n\n        // Ignore unchanged ratios\n        if (oldRatio === newRatio) return\n\n        for (var i = 0; i < this.thresholds.length; i++) {\n          var threshold = this.thresholds[i]\n\n          // Return true if an entry matches a threshold or if the new ratio\n          // and the old ratio are on the opposite sides of a threshold.\n          if (threshold == oldRatio || threshold == newRatio ||\n          threshold < oldRatio !== threshold < newRatio) {\n            return true\n          }\n        }\n      }\n\n\n  /**\n   * Returns whether or not the root element is an element and is in the DOM.\n   * @return {boolean} True if the root element is an element and is in the DOM.\n   * @private\n   */\n  IntersectionObserver.prototype._rootIsInDom = function() {\n    return !this.root || containsDeep(document, this.root)\n  }\n\n\n  /**\n   * Returns whether or not the target element is a child of root.\n   * @param {Element} target The target element to check.\n   * @return {boolean} True if the target element is a child of root.\n   * @private\n   */\n  IntersectionObserver.prototype._rootContainsTarget = function(target) {\n    return containsDeep(this.root || document, target)\n  }\n\n\n  /**\n   * Adds the instance to the global IntersectionObserver registry if it isn't\n   * already present.\n   * @private\n   */\n  IntersectionObserver.prototype._registerInstance = function() {\n    if (registry.indexOf(this) < 0) {\n      registry.push(this)\n    }\n  }\n\n\n  /**\n   * Removes the instance from the global IntersectionObserver registry.\n   * @private\n   */\n  IntersectionObserver.prototype._unregisterInstance = function() {\n    var index = registry.indexOf(this)\n    if (index != -1) registry.splice(index, 1)\n  }\n\n\n  /**\n   * Returns the result of the performance.now() method or null in browsers\n   * that don't support the API.\n   * @return {number} The elapsed time since the page was requested.\n   */\n  function now() {\n    return window.performance && performance.now && performance.now()\n  }\n\n\n  /**\n   * Throttles a function and delays its execution, so it's only called at most\n   * once within a given time period.\n   * @param {Function} fn The function to throttle.\n   * @param {number} timeout The amount of time that must pass before the\n   *     function can be called again.\n   * @return {Function} The throttled function.\n   */\n  function throttle(fn, timeout) {\n    var timer = null\n    return function () {\n      if (!timer) {\n        timer = setTimeout(function() {\n          fn()\n          timer = null\n        }, timeout)\n      }\n    }\n  }\n\n\n  /**\n   * Adds an event handler to a DOM node ensuring cross-browser compatibility.\n   * @param {Node} node The DOM node to add the event handler to.\n   * @param {string} event The event name.\n   * @param {Function} fn The event handler to add.\n   * @param {boolean} opt_useCapture Optionally adds the even to the capture\n   *     phase. Note: this only works in modern browsers.\n   */\n  function addEvent(node, event, fn, opt_useCapture) {\n    if (typeof node.addEventListener == 'function') {\n      node.addEventListener(event, fn, opt_useCapture || false)\n    }\n    else if (typeof node.attachEvent == 'function') {\n      node.attachEvent('on' + event, fn)\n    }\n  }\n\n\n  /**\n   * Removes a previously added event handler from a DOM node.\n   * @param {Node} node The DOM node to remove the event handler from.\n   * @param {string} event The event name.\n   * @param {Function} fn The event handler to remove.\n   * @param {boolean} opt_useCapture If the event handler was added with this\n   *     flag set to true, it should be set to true here in order to remove it.\n   */\n  function removeEvent(node, event, fn, opt_useCapture) {\n    if (typeof node.removeEventListener == 'function') {\n      node.removeEventListener(event, fn, opt_useCapture || false)\n    }\n    else if (typeof node.detatchEvent == 'function') {\n      node.detatchEvent('on' + event, fn)\n    }\n  }\n\n\n  /**\n   * Returns the intersection between two rect objects.\n   * @param {Object} rect1 The first rect.\n   * @param {Object} rect2 The second rect.\n   * @return {?Object} The intersection rect or undefined if no intersection\n   *     is found.\n   */\n  function computeRectIntersection(rect1, rect2) {\n    var top = Math.max(rect1.top, rect2.top)\n    var bottom = Math.min(rect1.bottom, rect2.bottom)\n    var left = Math.max(rect1.left, rect2.left)\n    var right = Math.min(rect1.right, rect2.right)\n    var width = right - left\n    var height = bottom - top\n\n    return (width >= 0 && height >= 0) && {\n      top: top,\n      bottom: bottom,\n      left: left,\n      right: right,\n      width: width,\n      height: height,\n    }\n  }\n\n\n  /**\n   * Shims the native getBoundingClientRect for compatibility with older IE.\n   * @param {Element} el The element whose bounding rect to get.\n   * @return {Object} The (possibly shimmed) rect of the element.\n   */\n  function getBoundingClientRect(el) {\n    var rect\n\n    try {\n      rect = el.getBoundingClientRect()\n    } catch (err) {\n      // Ignore Windows 7 IE11 \"Unspecified error\"\n      // https://github.com/w3c/IntersectionObserver/pull/205\n    }\n\n    if (!rect) return getEmptyRect()\n\n    // Older IE\n    if (!(rect.width && rect.height)) {\n      rect = {\n        top: rect.top,\n        right: rect.right,\n        bottom: rect.bottom,\n        left: rect.left,\n        width: rect.right - rect.left,\n        height: rect.bottom - rect.top,\n      }\n    }\n    return rect\n  }\n\n\n  /**\n   * Returns an empty rect object. An empty rect is returned when an element\n   * is not in the DOM.\n   * @return {Object} The empty rect.\n   */\n  function getEmptyRect() {\n    return {\n      top: 0,\n      bottom: 0,\n      left: 0,\n      right: 0,\n      width: 0,\n      height: 0,\n    }\n  }\n\n  /**\n   * Checks to see if a parent element contains a child element (including inside\n   * shadow DOM).\n   * @param {Node} parent The parent element.\n   * @param {Node} child The child element.\n   * @return {boolean} True if the parent node contains the child node.\n   */\n  function containsDeep(parent, child) {\n    var node = child\n    while (node) {\n      if (node == parent) return true\n\n      node = getParentNode(node)\n    }\n    return false\n  }\n\n\n  /**\n   * Gets the parent node of an element or its host element if the parent node\n   * is a shadow root.\n   * @param {Node} node The node whose parent to get.\n   * @return {Node|null} The parent node or null if no parent exists.\n   */\n  function getParentNode(node) {\n    var parent = node.parentNode\n\n    if (parent && parent.nodeType == 11 && parent.host) {\n      // If the parent is a shadow root, return the host element.\n      return parent.host\n    }\n\n    if (parent && parent.assignedSlot) {\n      // If the parent is distributed in a <slot>, return the parent of a slot.\n      return parent.assignedSlot.parentNode\n    }\n\n    return parent\n  }\n\n\n  // Exposes the constructors globally.\n  window.IntersectionObserver = IntersectionObserver\n  window.IntersectionObserverEntry = IntersectionObserverEntry\n}())"],
"names":["IntersectionObserverEntry","entry","time","target","rootBounds","boundingClientRect","intersectionRect","getEmptyRect","isIntersecting","targetRect","targetArea","width","height","intersectionArea","intersectionRatio","Number","toFixed","IntersectionObserver","callback","opt_options","options","Error","root","nodeType","_checkForIntersections","throttle","bind","THROTTLE_TIMEOUT","_callback","_observationTargets","_queuedEntries","_rootMarginValues","_parseRootMargin","rootMargin","thresholds","_initThresholds","threshold","map","margin","value","unit","join","fn","timeout","timer","setTimeout","removeEvent","node","event","opt_useCapture","removeEventListener","detatchEvent","getBoundingClientRect","el","rect","err","top","right","bottom","left","containsDeep","parent","child","getParentNode","parentNode","host","assignedSlot","window","prototype","Object","defineProperty","get","document","registry","disconnect","IntersectionObserver.prototype.disconnect","_unmonitorIntersections","_unregisterInstance","takeRecords","IntersectionObserver.prototype.takeRecords","records","slice","IntersectionObserver.prototype._initThresholds","opt_threshold","Array","isArray","sort","filter","t","i","a","isNaN","IntersectionObserver.prototype._parseRootMargin","opt_rootMargin","margins","split","parts","exec","parseFloat","IntersectionObserver.prototype._unmonitorIntersections","_monitoringIntersections","clearInterval","_monitoringInterval","_domObserver","IntersectionObserver.prototype._checkForIntersections","rootIsInDom","_rootIsInDom","rootRect","_getRootRect","forEach","item","element","rootContainsTarget","_rootContainsTarget","oldEntry","_computeTargetAndRootIntersection","newEntry","performance","now","_hasCrossedThreshold","push","length","IntersectionObserver.prototype._computeTargetAndRootIntersection","getComputedStyle","display","atRoot","parentRect","parentComputedStyle","body","documentElement","overflow","Math","max","min","IntersectionObserver.prototype._getRootRect","html","clientWidth","clientHeight","_expandRectByRootMargin","IntersectionObserver.prototype._expandRectByRootMargin","newRect","IntersectionObserver.prototype._hasCrossedThreshold","oldRatio","newRatio","IntersectionObserver.prototype._rootIsInDom","IntersectionObserver.prototype._rootContainsTarget","IntersectionObserver.prototype._unregisterInstance","index","indexOf","splice"]
}
