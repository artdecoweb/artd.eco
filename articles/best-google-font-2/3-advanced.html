## Advanced Loading: @lemuria/font

<p>
  As can be seen from the performance graphs above, there is one drawback to preloading web fonts stylesheets dynamically even with the preload link: fonts won't begin to download immediately after the stylesheet is downloaded, and will generally wait for after the initial render is finished. I've repeated the previous experiment multiple times, and I always see the same result. Plus, we're still to conglomerate all reflows. The proposed solution is JavaScript-based:
</p>

<ul>
  * Preload the stylesheet as `fetch` resource.
  * Instead of adding the link with the stylesheet to DOM, download it using XHR.
  * Parse the stylesheet to extract `url()` links to fonts, add them do DOM as `link` with _rel_=<strong>preload</strong> _as_=<strong>font</strong>. This will kick in downloading the fonts.
  * Wait for all fonts to load, then embed the stylesheet as inline style. This solves the problem.
  * If the browser doesn't support preload, just fallback to standard font loading.
</ul>

<p>
  Here's a simple to fetch stylesheet, while measuring performance:
</p>

```js
/**
* @param {string} address The address to load.
* @param {function(string)} cb The callback to call on complete.
* @param {string} [marker] Performance annotation.
*/
const fetchStylesheet = (address, cb, marker = '') => {
 performance.mark('xhr-start'+marker)
 const xhr = new XMLHttpRequest()
 xhr.onreadystatechange = () => {
   if(xhr.readyState == 4) {
     if (xhr.status == 200) {
       cb(xhr.responseText)
       performance.mark('xhr-end'+marker)
       performance.measure('xhr'+marker, 'xhr-start'+marker, 'xhr-end'+marker)
     } else {
       console.error('Error loading webfont: server responded with code %s at %s',
        xhr.status, address)
     }
   }
 }
 xhr.open('GET', address)
 try {
   xhr.send(null)
 } catch (err) {
   console.error(err)
 }
}
```

<p>
  Our stylesheet parsing function uses a regex to extract URLs with unicode ranges of fonts, and creates an array like `[{ font: 'url', range: /[regex]/ }]` for each font it found in the stylesheet.
</p>

```js
function parseBody(result) {
  const re = /url\((.+?)\).*?;\s+unicode-range: (.+?);/g
  let ranges = {}
  const fonts = []
  let a
  while((a = re.exec(result))) {
    const u = a[1]
    const range = a[2]
    fonts.push({ url: u, range })
    ranges[range] = 1
  }
  ranges = Object.keys(ranges).reduce((acc, range) => {
    const reg = range
      .split(/,\s/)
      .map((r) => r.replace('U+', '\\u').replace('-', '-\\u'))
      .join('').toLowerCase()
    acc[range] = new RegExp(`[${reg}]`)
    return acc
  }, {})
  // ...
```

<p id="2-scenarios">
  There are 2 scenarios when we'll get the stylesheet ready: A) prior to HTML parsing, which can be because there's another stylesheet blocking the render, and because the connection is very fast; and B) after HTML parsing, when `body` is available. In the first instance, we wouldn't know the unicode ranges that are present on the page, therefore they have to be supplied as additional information. If we know that we don't use *latin-ext* on the page, we'll just pass the unicode range for *latin* characters. This way, we don't have to download each single font in the stylesheet, wasting data.
</p>

```js
  // ..
  const body = document.body ? document.body.textContent : ''
  const validRanges = body ? Object.keys(ranges).reduce((acc, range) => {

    // case B) body is loaded, text it against the regex.
    const reg = ranges[range]
    const valid = reg.test(body)
    if (valid) acc[range] = true
    return acc
  }, {}) : Object.keys(ranges).reduce((acc, range) => {

    // case A) body is not available, fallback to supplied ranges.
    const valid = range in defaultRanges
    if (valid) acc[range] = true
    return acc
  }, {})

  // filter only fonts we need
  urls = fonts.filter(({ range }) => {
    return range in validRanges
  }).map(({ url: u }) => u)

  // if ranges are not supplied, and we're in case A, just add the stylesheet.
  // we loose the advantage of eliminating continuous reflows due to fonts
  // arriving independently at different times.
  if (!urls.length) return loadedCb()

  // preload fonts via link elements
  // each appendChild has a cost, so bundle them into a fragment.
  const fragment = document.createDocumentFragment()
  urls.forEach((address, i) => {
    const link = document.createElement('link')
    link.href = address
    link.rel = 'preload'
    link.as = 'font'
    const j = i + 1
    performance.mark('link-preload-start'+j)
    link.onload = () => loadedCb(j)
    link.setAttribute('crossorigin', true)
    fragment.appendChild(link)
  })
  document.head.appendChild(fragment)
}
```

<p>
  Add some logic to keep track of parallel preloads, and embed the stylesheet when they all arrive.
</p>

```js
let FONT_CSS
let urls = []
let loaded = 0

// the entry main: fetch CSS and call parseBody,
// which will call loadedCb for each font.
function startPreload(linkEl, marker = 'link') {
  const href = linkEl.href
  fetchStylesheet(href, (res) => {
    FONT_CSS = res
    parseBody(FONT_CSS)
  }, '-' + marker)
}

/**
 * @param {number} [i] The index of the link
 */
const loadedCb = (i) => {
  if (i) {
    performance.mark('link-preload-end'+i)
    performance.measure('link-preload', 'link-preload-start'+i, 'link-preload-end'+i)
  }
  loaded++
  if (loaded >= urls.length) {
    const style = document.createElement('style')
    style.innerHTML = FONT_CSS
    document.head.appendChild(style)

    performance.mark('agf-end')
    performance.measure('@lemuria/font', 'agf-start', 'agf-end')
  }
}

// kick in advanced google font preloading!
startPreload({ href: FONT }, 'js')
```

<p>
  I could have used the `fetch` instead of XHR since its 2019, however I would need to add a polyfill and transpile async code. There's no performance difference between `fetch` and `XMLHttpRequest` APIs. One observation, is that with `fetch`, data could be streamed, so if the response arrived in chunks, I could extract fonts as they come, but because the stylesheet is so small (&lt; 1kb), streaming is unnecessary. I've made a package called `@lemuria/font` with this code which I run through _Google Closure Compiler_, so let's update our page:
</p>

```html
<head>
  <link rel="dns-prefetch" href="//fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link rel="preload" href="https://fonts.googleapis.com/css?display=swap&family=Gentium+Basic:400,400i,700|Limelight" as="fetch">
  <script>
    (function(){window["@lemuria/font"]=function(q,k){function x(a){for(var f=/url\((.+?)\).*?;\s+unicode-range: (.+?);/g,b={},d=[],h;h=f.exec(a);){var r=h[2];d.push({url:h[1],a:r});b[r]=1}b=Object.keys(b).reduce(function(c,e){var g=e.split(/,\s/).map(function(l){return l.replace("U+","\\u").replace("-","-\\u")}).join("").toLowerCase();c[e]=new RegExp("["+g+"]");return c},{});var t=document.body?document.body.textContent:"",y=t?Object.keys(b).reduce(function(c,e){b[e].test(t)&&(c[e]=!0);return c},{}):Object.keys(b).reduce(function(c,
    e){e in k&&(c[e]=!0);return c},{});m=d.filter(function(c){return c.a in y}).map(function(c){return c.url});if(!m.length)return u();var v=document.createDocumentFragment();m.forEach(function(c,e){var g=document.createElement("link");g.href=c;g.rel="preload";g.as="font";var l=e+1;performance.mark("link-preload-start"+l);g.onload=function(){return u(l)};g.setAttribute("crossorigin",!0);v.appendChild(g)});document.head.appendChild(v)}k=void 0===k?{}:k;var n=document.createElement("link");if(function(a,
    f){if(!a||!a.supports)return!1;try{return a.supports(f)}catch(b){return!1}}(n.relList,"preload")){var z=function(a,f,b){b=void 0===b?"":b;performance.mark("xhr-start"+b);var d=new XMLHttpRequest;d.onreadystatechange=function(){4==d.readyState&&(200==d.status?(f(d.responseText),performance.mark("xhr-end"+b),performance.measure("xhr"+b,"xhr-start"+b,"xhr-end"+b)):console.error("Error loading webfont: server responded with code %s at %s",d.status,a))};d.open("GET",a);try{d.send(null)}catch(h){console.error(h)}};
    performance.mark("agf-start");var p;(function(a,f){z(a.href,function(b){p=b;x(p)},"-"+(void 0===f?"link":f))})({href:q},"js");var m=[],w=0,u=function(a){a&&(performance.mark("link-preload-end"+a),performance.measure("link-preload","link-preload-start"+a,"link-preload-end"+a));w++;w>=m.length&&(a=document.createElement("style"),a.innerHTML=p,document.head.appendChild(a),performance.mark("agf-end"),performance.measure("@lemuria/font","agf-start","agf-end"))}}else n.rel="stylesheet",n.href=q,document.head.appendChild(n)};}).call(this);

    window['@lemuria/font']
      ('https://fonts.googleapis.com/css?display=swap&family=Gentium+Basic:400,400i,700|Limelight')
  </script>
</head>
```

<p>
  I've left plenty of performance markers, but there's a version that doesn't have them. What does the resulting timeline look like? Have we solved the problem of throttling fonts' reflows?
<p>

<fig id="advanced-loading" src="./graphics/dev8.png">
  Advanced asynchronous Google Font performance: achieving single reflow.
</fig>

<ol>
  * As soon as the page starts parsing, we begin the XHR request, but the XHR resource has already started downloading. The script evaluation takes _10ms_.
  * The download completes, but the thread is blocked. The XHR waits until it's freed to call the callback. Fonts don't begin to download but we can't do anything about it. Once the thread is available, we inject 4 links and assign an `onload` listener to each them.
  * When all `onload` events have fired, we add the stylesheet to DOM as a style. Despite the fact that fonts arrived at different times, we only see one reflow which takes 100ms. The page's `onload` event is thus delivered quicker and the users and Google are happy.
</ol>

<p>
  Bingo bongo, we've achieved the maximum optimisation of a Google Font. Let's just see what if there's a render blocking resource, such as an external CSS that would give us some additional time to fetch the web font stylesheet:
</p>

<fig src="./graphics/dev9.png">
  @Lemuria/font parsing starting before body is available without default unicode-ranges.
</fig>

<ol>
  * The advanced font loading script is executed, and taps into the preload download, but by the time the XHR is finished, the script cannot find `body` and there are no default unicode ranges. It falls back to essentially just appending a link tag with the style to the head.
  * The external stylesheet is begins to parse only now.
  * Fonts arrive one by one.
</ol>

<p>
  In this experiment, instead of inlining the page style, I added a link to it, so that the browser has to download it. Although such download happens really quickly, the page nevertheless is slowed down by much more than just the download time. Unlike in the previous case, now when the `@lemuria/font` function is executed, the body is still not available because the parsing has not started. This just shows that it's not just the download speed that increases the start up time for external stylesheets, but their loading time also _total: 84.12 ms (15.12 ms network transfer + 69.01 ms resource loading)_.</p>

  <p>For a scary moment though, I thought that I might be giving wrong advice when saying to append a `link` tag dynamically into the head, and it will actually block the page from rendering. For example, on the graph above, there are some gaps in the timeline after the web font stylesheet is inserted, but before the external CSS is parsed, that could indicate that the page was render-blocked. However, it's not the case as shown below, and the reason for these gaps is that the browser has to pause to parse the external style, allowing some async JS to report to the main thread via callbacks (e.g., here, XHR is completed quicker compared to the [previous case](#fig-advanced-loading), where it had to wait for the main thread to unlock since there were no gaps). Below is the proof.
</p>

<fig src="./graphics/dev-check.gif">
  Dynamic insertion of a link with JS does not block page render.
</fig>

<p>
  Essentially all I've done is added an external stylesheet dynamically, but throttled it server-side with a middleware function. Because the page continued to render, it's safe to say that adding a link with JS in the head will not block the main thread.
</p>

```html
<head>
<link rel="preload" href="/throttle.css" as="style">
  <script>
    const link = document.createElement('link')
    link.href = '/throttle.css'
    link.rel = 'stylesheet'
    performance.mark('add-stylesheet')
    document.head.appendChild(link)
    link.onload = () => {
      performance.measure('stylesheet-onload', 'add-stylesheet');
    }
  </script>
</head>
```

```js
// Koa middleware
async throttle(ctx, next) {
  if (ctx.path == '/throttle.css') {
    await new Promise(r => setTimeout(r, 500))
    ctx.type = 'text/css'
    ctx.body = ''
  }
  await next()
}
```

<p>
  So finally, let me show a case with an external stylesheet, and with unicode-range. The unicode-range can be looked up in the Google's servers response, but I'm quite sure they are pretty static so you wouldn't have to do it often (but keep an eye out for them).
</p>

```html
<head>
  <link rel="preload" crossorigin href="https://fonts.googleapis.com/css?display=swap&family=Gentium+Basic:400,400i,700|Limelight" as="fetch">
  <script>
    // @lemuria/font source
    var range = 'U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, ' +
                'U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD'
    window['@lemuria/font']
      ('https://fonts.googleapis.com/css?display=swap&family=Gentium+Basic:400,400i,700|Limelight', {
        [range]: true, // latin range
      })
  </script>
</head>
```

<fig src="./graphics/dev10.png">
  @Lemuria/font with unicode-range info allows to download fonts in parallel to the main thread.
</fig>

<ol>
  * The font script begins the XHR request as soon as HTML starts to parse. It might look like the thread is blocked because the browser is not doing anything during the XHR, however it's not so otherwise there would be a long solid orange line saying "Evaluating JS", but there's just a gap. The browser is doing something, but there's no info to it. The XHR is async so it's not blocking the thread.
  * The XHR is finished but the body is not present. Because we've passed the desired `unicode-range`, the script inserts the font preload links, and they begin to download. This allows to parallelise their download with the initial render.
  * Once the thread is freed (the <span style="background:blue; color:white" class="px-2"><abbr title="Dom Content Loaded">DCL</abbr></span> event), there's a bit of work to do for other JS scripts on the page, after which the web font stylesheet is applied. Notice there's only _150ms_ delay between the <span style="background:green; color:white" class="px-2"><abbr title="First Paint">FP</abbr></span> and fonts being added which gives us the fastest FOUT so far.
</ol>

<p>
  Cool, I think we've optimised as much as possible out of _Google Fonts_. The final version enables to insert the stylesheet before the initial layout, and also downloads fonts in parallel to the main thread which is busy rendering. This is only possible if there are render blocking resources which will postpone the parsing for some time long enough for the web font stylesheet preload to complete. In case there are none, I've tried the following trick:
</p>

```html
<head>
  <!-- ... -->
  <link href="data:text/css;charset=utf-8," rel="stylesheet">
</head>
```

<p>
  In words, I added a data-url link in hope that the browser will pause to download it which will give the XHR callback a chance to fire (it <a href="#fig-advanced-loading" onclick="document.querySelector(this.getAttribute('href')).scrollIntoView({behavior: 'smooth'}); return false">does not fire</a> if there are no external resources), however that didn't work 🤷‍♀️. Let me wrap up to conclusions.
</p>

<section-break />